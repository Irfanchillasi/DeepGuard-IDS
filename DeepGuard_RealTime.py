"""
DeepGuard: Real-Time Industrial Deployment Module
-------------------------------------------------
This script demonstrates how to deploy the trained DeepGuard model
into a live SCADA environment using Modbus/TCP.

Requirements:
- pip install pymodbus numpy
- A valid 'deepguard_model_profile.npy' (Generated by DeepGuard_Source_Code.py)
"""

import numpy as np
import time
import os
import sys

# Try importing Modbus, handle validation
try:
    from pymodbus.client import ModbusTcpClient
    MODBUS_AVAILABLE = True
except ImportError:
    MODBUS_AVAILABLE = False

class DeepGuardMonitor:
    def __init__(self, plc_ip="127.0.0.1", port=5020):
        self.plc_ip = plc_ip
        self.port = port
        self.client = None
        
        # Load the "Brain" (Trained Profile)
        if not os.path.exists("deepguard_model_profile.npy"):
            print("ERROR: Model profile not found! Run DeepGuard_Source_Code.py first.")
            sys.exit(1)
            
        print("Loading DeepGuard Model Profile...")
        model_data = np.load("deepguard_model_profile.npy")
        self.means = model_data[0]
        self.stds = model_data[1]
        self.n_sensors = len(self.means)
        print(f"Model Loaded. Tracking {self.n_sensors} sensors.")

        # Threshold from Training
        self.THRESHOLD = 4.5

    def connect(self):
        if MODBUS_AVAILABLE:
            print(f"Connecting to PLC at {self.plc_ip}:{self.port}...")
            # This is a real connection attempt.
            self.client = ModbusTcpClient(self.plc_ip, port=self.port)
            connected = self.client.connect()
            
            if connected:
                print("SUCCESS: Connected to Industrial Controller.")
                return True
            else:
                print("WARNING: Could not connect to real PLC (Target unreachable). switch to DEMO MODE.")
                return False
        else:
            print("WARNING: 'pymodbus' library not installed. Running in DEMO MODE.")
            return False

    def read_sensors(self):
        """
        Reads 51 registers starting from address 0.
        """
        if self.client and self.client.connected:
            # REAL WORLD CODE:
            response = self.client.read_holding_registers(address=0, count=self.n_sensors)
            if not response.isError():
                # Convert integers back to floats (simplification for demo)
                return np.array(response.registers, dtype=float)
            else:
                print("Read Error")
        
        # DEMO MODE: Simulate live data
        
        # DEMO MODE: Simulate live data
        # Generate a "Normal" reading
        reading = self.means + np.random.normal(0, 0.1, self.n_sensors)
        
        # Randomly inject an attack every 20 cycles
        if np.random.rand() < 0.05:
            # Attack Sensors 10, 11, 12
            reading[10:13] += 5.0 
            print(">>> [SIMULATED ATTACK INJECTION] <<<")
            
        time.sleep(0.5) # Simulate network latency
        return reading

    def protect(self):
        print("\n--- STARTING DEEPGUARD REAL-TIME MONITORING ---")
        print("Press Ctrl+C to stop.")
        
        running_mode = self.connect()
        
        try:
            while True:
                # 1. Acquire Data (Real or Simulated)
                live_data = self.read_sensors()
                
                # 2. Preprocessing (Normalize using Training Stats)
                # Standardize: (X - Mean) / Std
                norm_data = (live_data - self.means) / (self.stds + 1e-6)
                
                # 3. Inference (Calculate Anomaly Score)
                z_scores = np.abs(norm_data)
                max_deviation = np.max(z_scores)
                
                # 4. Decision
                timestamp = time.strftime("%H:%M:%S")
                
                if max_deviation > self.THRESHOLD:
                    # !!! THREAT DETECTED !!!
                    print(f"[{timestamp}] ðŸš¨ ALERT! Anomaly Score: {max_deviation:.2f} (Threshold: {self.THRESHOLD})")
                    print(f"            Affected Sensors: {np.where(z_scores > self.THRESHOLD)[0]}")
                    
                    # IN REAL LIFE: ADD PLC SHUTDOWN CODE HERE
                    # if MODBUS_AVAILABLE:
                    #    self.client.write_coil(999, True) # Trigger Emergency Stop Coil
                    
                else:
                    # Normal
                    sys.stdout.write(f"\r[{timestamp}] âœ… System Normal. Max Dev: {max_deviation:.2f}   ")
                    sys.stdout.flush()
                    
        except KeyboardInterrupt:
            print("\n\nStopping Monitor...")
            if self.client:
                self.client.close()

if __name__ == "__main__":
    bot = DeepGuardMonitor()
    bot.protect()
